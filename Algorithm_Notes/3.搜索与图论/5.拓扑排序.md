# 拓扑排序(有向图)

## 有向图的拓扑序列

给定一个 n个点 m条边的有向图，点的编号是 1到 n，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 ?1。

若一个由图中所有点构成的序列 A满足：对于图中的每条边 (x,y)，x在 A中都出现在 y之前，则称 A是该图的一个拓扑序列。

输入格式

第一行包含两个整数 n和 m

接下来 m行，每行包含两个整数 x和 y，表示存在一条从点 x到点 y的有向边 (x,y)

输出格式

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。否则输出 ?1

数据范围

1≤n,m≤10^5

```
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int maxn=1e5+10;

int e[maxn],ne[maxn],h[maxn],d[maxn];
int q[maxn]; 
int n,m,idx;

void add(int a,int b)
{
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}

int tp()
{
	int tt=-1;//开始没有节点入队，tt初始化为-1
	int hh=0;
	
	for(int i=1;i<=n;i++){
		if(d[i]==0){
			q[++tt]=i;//入度为零可以入队 
		}
	}
	
	while(hh<=tt)
	{
		int t=q[hh++];
		
		for(int i=h[t];i!=-1;i=ne[i]){
			int j=e[i];//这里代表t有一条边指向j 
			d[j]--;
			if(d[j]==0){
				q[++tt]=j;
			}
		}	
		
	}
	if(tt==n-1){
		for(int i=0;i<n;i++){
			cout<<q[i]<<" ";
		}
	}
	else{
		cout<<"-1"<<endl;
	}
	
	
	
}


int main()
{
	cin>>n>>m;
	memset(h,-1,sizeof(h));
	for(int i=0;i<m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
		d[b]++;//有a->b的边，b的入度++
	}
	tp();
	return 0;
}
```
