# 最短编辑距离

## 最短编辑距离

给定两个字符串 A和 B，现在要将 A经过若干操作变为 B，可进行的操作有：

删除C将字符串 A中的某个字符删除。
插入C在字符串 A的某个位置插入某个字符。

替换C将字符串 A中的某个字符替换为另一个字符。

现在请你求出，将 A变为 B至少需要进行多少次操作。


```
//状态表示 ：f[i][j]
//将a[1~i]变成b[1~j]的操作方式,属性：min 

//1、如果最后一步是增加最后一个字符，那么f[i][j] = f[i][j - 1] + 1;
//2、如果最后一步是删除最后一个字符，那么f[i][j] = f[i - 1][j] + 1;
//3、如果最后一步不是增加最后一个字符也不是删除最后一个字符，
//那么最后一步剩下的两种操作是：
//a、将最后一个字符进行替换，那么f[i][j] = f[i - 1][j - 1]+1;
//b、由于这是最后一步操作，也就是经过这一步操作之后，字符串a才会变成字符串b，
//而对最后一个字符的操作之前都已经论述了，
//因此最后一步就不是对最后一个字符进行操作，换句话来说，
//字符串a的最后一个字符已经和字符串b的最后一个字符匹配好了，
//我们已经不需要考虑最后一个字符了，现在只要考虑之前的字符匹配情况，
//也就是将a[1 ~ i - 1]与b[1 ~ j - 1]匹配好，整个转化的过程就结束了。
//因此最后这种情况的编辑距离就是f[i - 1][j - 1] + 0;
//综上所述，我们完整的把这个问题不重不漏的划分成了四个子问题。

//只要最后一步操作不是对最后一个字符进行操作，
//那我们就可以将这个问题划分为其子问题，
//也就是a[1 ~ i - 1]与b[1 ~ j - 1]匹配的问题。
//这个子问题划分到最后，最终会将i或j减到1，不能继续再减，
//那么此时的问题就会是对最后一个字符进行修改或增删。
//因此整个逻辑是闭环的。


#include<iostream>
using namespace std;

const int maxn=1010;
int n,m;
char a[maxn],b[maxn];
int dp[maxn][maxn];

int main()
{
	scanf("%d%s",&m,a+1);
	scanf("%d%s",&n,b+1);
	
	//初始化 
	//a的i长度字串要通过删除和b的0长度字串匹配要进行i步删除 
	for(int i=0;i<=m;i++){
		dp[i][0]=i;
	}
	
	//a的0长度字串要通过增加和b的i长度字串匹配要进行i步增加
	for(int i=0;i<=n;i++){
		dp[0][i]=i;
	}
	
	
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			//通过增加或者删除最后一位实现a的第i位和b的第j位相等 
			dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1;
			//如果最后一位相等，就不用进行修改操作，否则修改 
			if(a[i]==b[j]){
				dp[i][j]=min(dp[i][j],dp[i-1][j-1]);
			}
			else{
				dp[i][j]=min(dp[i][j],dp[i-1][j-1]+1);
			}
		}
	}
	printf("%d\n",dp[m][n]);
	
	return 0;
}

```



## 编辑距离问题

给定 n个长度不超过 10的字符串以及 次询问，每次询问给出一个字符串和一个操作次数上限。

对于每次询问，请你求出给定的 n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。

每个对字符串进行的单个字符的插入、删除或替换算作一次操作。

样例：
```
3 2
abc
acd
bcd
ab 1
acbd 2
```
```
1
3
```

```
#include<iostream>
#include<string.h>
using namespace std;
const int maxn=1010;

char str[maxn][15];
int dp[15][15];

//a是要改变的，b是目标数组 
int gh(char a[],char b[])
{
	int la=strlen(a+1);//注意字符串开始下标为1，所以计算长度时候从1开始计算
	int lb=strlen(b+1);
	
	for(int i=0;i<=la;i++){
		dp[i][0]=i;
	}
	for(int i=0;i<=lb;i++){
		dp[0][i]=i;
	}
	
	for(int i=1;i<=la;i++){
		for(int j=1;j<=lb;j++){
			dp[i][j]=min(dp[i-1][j],dp[i][j-1])+1;
			dp[i][j]=min(dp[i][j],dp[i-1][j-1]+!(a[i]==b[j]));
		}
	}
	return dp[la][lb];
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){
		scanf("%s",str[i]+1);//注意输入方式，从每个字符串第一个开始输入
	}
	
	while(m--)
	{
		char s[15];
		int tim;
		scanf("%s%d",s+1,&tim);
		
		int res=0;
		for(int i=0;i<n;i++){
			if(gh(str[i],s)<=tim){
				res++;
			}
		}
		printf("%d\n",res);
	}
	
	
	return 0;
}

```