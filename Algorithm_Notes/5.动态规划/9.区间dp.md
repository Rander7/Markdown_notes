# 区间dp

## 石子合并

设有 N
 堆石子排成一排，其编号为 1,2,3,…,N
。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 4堆石子分别为 1 3 5 2， 我们可以先合并 1、2堆，代价为 4，得到 4 5 2， 又合并 1、2堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4++11=24
；

如果第二步是先合并 2、3堆，则代价为 7
，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价

```

#include<iostream>
using namespace std;

const int maxn=510;

int f[maxn][maxn];
int s[maxn];//区间和

int main()
{
	int n;
	scanf("%d",&n);
	
	for(int i=1;i<=n;i++){
		scanf("%d",&s[i]);
	}
	for(int i=1;i<=n;i++){
		s[i]+=s[i-1];
	}
	
	//令f[i][j]为将第i堆和第j堆之间合并最小代价
	//可以从中去一个区间点，将大问题分解成小问题
	//最小问题为当区间长度为1时候，代价为0
	//此处区间长度指区间中包含的点的个数
	
	for(int len=2;len<=n;len++){
		for(int i=1;i+len-1<=n;i++){//之所以要-1是因为区间长度定义 
			int j=i+len-1;//区间终点 
			f[i][j]=1e8;//将f初始化为一个很大的值 
			for(int k=i;k<=j-1;k++){//枚举包含在区间内的分界点 
				f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1]);
			} 
		}
	} 
	printf("%d\n",f[1][n]);
	
	
	return 0;
} 
```
