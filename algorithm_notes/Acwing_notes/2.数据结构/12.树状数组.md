# 树状数组

## 楼兰图腾
https://www.acwing.com/problem/content/243/

在完成了分配任务之后，西部 314来到了楼兰古城的西部。

相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(V)，一个部落崇拜铁锹(∧)，他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。

西部 314在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n个点，经测量发现这 n个点的水平位置和竖直位置是两两不同的。

西部 314认为这幅壁画所包含的信息与这 n个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)，其中 y1?yn是 1到 n的一个排列。

西部 314打算研究这幅壁画中包含着多少个图腾。

如果三个点 (i,yi),(j,yj),(k,yk)满足 1≤i<j<k≤n且 yi>yj,yj<yk，则称这三个点构成 V 图腾;

如果三个点 (i,yi),(j,yj),(k,yk)满足 1≤i<j<k≤n且 yi<yj,yj>yk，则称这三个点构成 ∧ 图腾;

西部 314想知道，这 n个点中两个部落图腾的数目。

因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。

输入格式

第一行一个数 n

第二行是 n个数，分别代表 y1，y2,…,yn

输出格式

两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数。

数据范围

对于所有数据，n≤200000，且输出答案不会超过 int64。y1?yn是 1到 n的一个排列。

```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>

using namespace std;

const int maxn=200010;
int a[maxn];
int tr[maxn];
int great[maxn],lower[maxn];

int n;

int lowbit(int x)
{
	return x&-x;
}

void add(int x,int c)
{
	for(int i=x;i<=n;i+=lowbit(i)){
		tr[i]+=c;
	}
}

int qua(int x)
{
	int sum=0;
	for(int i=x;i;i-=lowbit(i)){
		sum+=tr[i];
	}
	return sum;	
}


int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	
	for(int i=1;i<=n;i++){
		int y=a[i];
		great[i]=qua(n)-qua(y);
		lower[i]=qua(y-1);
		add(y,1);
	}
	
	memset(tr,0,sizeof(tr));
	long long res_a=0;
	long long res_v=0;
	
	for(int i=n;i>=1;i--){
		int y=a[i];
		res_v+=(long long)great[i]*(qua(n)-qua(y));
		res_a+=(long long)lower[i]*qua(y-1);
		add(y,1);
	}
	printf("%lld %lld",res_v,res_a);
	
	return 0;
}
```