# 最长公共子序列

不是严格相邻

```
//f[i][j]表示在第一个序列的前i个字母中出现
//并且在第二个序列的前j个字母中出现的最大值 

//可以分成两个半边考虑
//按两个序列末尾字符是否相等来区分

//1. 如果序列末尾字符相等，f[i][j]=f[i-1][j-1]+1
//2. 如果不相等，分成两种情况：
//(1)a[i]包含在最长公共子序列中f[i-1][j]
//(2)b[j]包含在最长公共子序列中 f[i][j-1]
//但是上面两种情况存在重叠 
//因为f[i][j]含义是前i/前j个字母出现最大值
//也就是最后的a[i]/b[j]不一定出现在末尾
//求max有重叠没关系 

#include<iostream>
using namespace std;

const int maxn=1010;
int n,m;
char a[maxn],b[maxn];
int f[maxn][maxn];

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s%s",a+1,b+1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i]==b[j]){
				f[i][j]=f[i-1][j-1]+1;
			}
			else{
				f[i][j]=max(f[i-1][j],f[i][j-1]);
			}
		}
	}
	printf("%d\n",f[n][m]);
	
	return 0;
}
```