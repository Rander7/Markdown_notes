# 并查集

## 合并集合
一共有 n个数，编号是 1?n，最开始每个数各自在一个集合中。现在要进行 m个操作，操作共有两种：

M a b，将编号为 a和 b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；

Q a b，询问编号为 a和 b的两个数是否在同一个集合中；

输入格式第一行输入整数 n和 m

接下来 m行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。

输出格式

对于每个询问指令 Q a b，都要输出一个结果,如果 a和 b在同一集合内，则输出 Yes，否则输出 No。

```
#include<iostream>
using namespace std;

const int maxn=1e5+10;

int p[maxn];//存放父节点下标 
int n;
int m;

int find(int x)//递归路径压缩，同时把路径上所有点p[x]指向根节点 
{
	if(p[x]!=x){
		p[x]=find(p[x]);
	}
	return p[x];
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		p[i]=i;//先将值初始化为自己下标 
	}
	while(m--)
	{
		char op[2];
		int a,b;
		scanf("%s%d%d",op,&a,&b);
		if(op[0]=='M'){
			p[find(a)]=find(b);//将a所在的祖先合并到b树中 
		}
		else{
			if(find(a)==find(b)){
				puts("Yes");
			}
			else{
				puts("No");
			}
		}	
	}
	
	return 0;
}
```


## 连通块中点的数量
给定一个包含 n个点（编号为 1?n）的无向图，初始时图中没有边。

现在要进行 m个操作，操作共有三种：

C a b，在点 a和点 b之间连一条边，a和 b可能相等；

Q1 a b，询问点 a和点 b是否在同一个连通块中，a和 b可能相等；

Q2 a，询问点 a所在连通块中点的数量；

输入格式

第一行输入整数 n和 m

接下来 m行，每行包含一个操作指令，指令为 C a b，Q1 a b 或 Q2 a 中的一种。

输出格式

对于每个询问指令 Q1 a b，如果 a和 b在同一个连通块中，则输出 Yes，否则输出 No。

对于每个询问指令 Q2 a，输出一个整数表示点 a所在连通块中点的数量,每个结果占一行。


```
#include<iostream>

using namespace std;

const int maxn=1e5+10;

int p[maxn],size1[maxn];
int n,m;


int find(int x)//递归路径压缩，同时把路径上所有点p[x]指向根节点 
{
	if(p[x]!=x){
		p[x]=find(p[x]);
	}
	return p[x];
}

int  main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		p[i]=i;
		size1[i]=1;
	}
	
	while(m--)
	{
		string s;
		cin>>s;
		if(s=="C"){
			int a,b;
			cin>>a>>b;
			if(find(b)==find(a)){
				continue;
			}
			size1[find(b)]+=size1[find(a)];//先累加区间值再合并
			p[find(a)]=find(b);
		}
		else if(s=="Q1"){
			int a,b;
			cin>>a>>b;
			if(find(a)==find(b)){
				puts("Yes");
			}
			else{
				puts("No");
			}
		}
		else if(s=="Q2"){
			int a;
			cin>>a;
			cout<<size1[find(a)]<<endl;
			
		}
		
	}
	
	
	
	return 0;
}
```

## 食物链
动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。

A吃 B，B吃 C，C吃 A

现有 N个动物，以 1?N编号。

每个动物都是 A,B,C中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 N个动物所构成的食物链关系进行描述：

第一种说法是 1 X Y，表示 X和 Y是同类。

第二种说法是 2 X Y，表示 X吃 Y

此人对 N个动物，用上述两种说法，一句接一句地说出 K句话，这 K句话有的是真的，有的是假的。

当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

当前的话与前面的某些真的话冲突，就是假话；
当前的话中 X或 Y比 N大，就是假话；
当前的话表示 X吃 X，就是假话。你的任务是根据给定的 N和 K句话，输出假话的总数。

输入格式

第一行是两个整数 N和 K，以一个空格分隔。

以下 K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中 D表示说法的种类。

若 D=1，则表示 X和 Y是同类。

若 D=2，则表示 X吃 Y

输出格式

只有一个整数，表示假话的数目。

```
#include<iostream>

using namespace std;

const int maxn=5e4+10;
int n,k;
int p[maxn],d[maxn];
int res;


int find(int x)
{
	if(p[x]!=x)//不是根节点 
	{
		int t=find(p[x]);
		d[x]=d[x]+d[p[x]];//当前到根节点的距离等于当前节点到父节点距离加父节点到根节点距离 
		p[x]=t;//将父节点改成根节点 
	}
	return p[x];//返回根节点 
}

int main()
{
	cin>>n>>k;
	for(int i=0;i<n;i++){
		p[i]=i;
	}
	
	while(k--)
	{
		int c,x,y;
		cin>>c>>x>>y;
		
		//首先如果 X或 Y比 N大，就是假话
		if(x>n||y>n){
			res++;
		}
		else
		{
			//话语意思是x与y同类 
			//首先把x和y的根节点返回出来 
			//每个都有两种情况，xy在同一集合，xy在不同集合 
			int px=find(x),py=find(y);
			if(c==1){
				//在同一个集合并且xy到根节点%3距离不同 
				if(px==py&&(d[y]-d[x])%3){
					res++;
				}
				//另一个情况两个不在同一个集合 
				else if(px!=py){
					//首先要把他们放到一个集合
					//然后重新将距离赋值
					p[px]=py;//把x的根节点放到y集合中 
					//要让他们属于同一个类，必须他们到新的根节点距离相同
					d[px]=d[y]-d[x];
				}
			}
			//语句意思是x吃y 
			else{
				//如果xy在同一个集合并且x距离%3不比y距离%3多1 
				//x==y情况包括在if中了 
				if(px==py&&(d[x]-d[y]-1)%3){
					res++;
				}
				else if(px!=py){
					p[px]=py;
					d[px]=d[y]-d[x]+1;	
				}
			}	
		}
	}
	cout<<res<<endl;
	return 0;
}
```


