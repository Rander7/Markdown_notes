# 二分算法

## 代码模板讲解
https://blog.csdn.net/WJPnb1/article/details/126360962

```
int L=-1,R=n;
while(L+1!=R)
{
	int mid=L+R>>1;
	if(check()) L=mid;
	else R=mid;
	//最后根据你所分左右两边区间的结果
	//选取L或者R作为结果
}
```

**衍生：**

**1. 求符合条件第一个数**
```
#include<iostream>
using namespace std;
int main()
{
int a[6]={1,2,2,3,3,4};
int l=-1,r=6;//定义两个指针
while(l+1!=r)
{
	int mid=l+r>>1;
    //找到中间位置的数发现他大于x，不断缩小右指针，最后右指针指向第一个>=x位置
	if(a[mid]>=3) 
        r=mid;
	else 
        l=mid;		   
}
cout<<"第一个3所在的下标为  "<<r<<endl;
return 0;
}	
```
**2. 求符合条件最后一个数**

```
#include<iostream>
using namespace std;
int main()
{
int a[6]={1,2,2,3,3,4};
int l=-1,r=6;//定义两个指针
while(l+1!=r)
{
	int mid=l+r>>1;
    //不断比较mid对应的值和x关系，如果mid对应值<=x就不断右移左指针，，最后左指针位置就是最后一个符合条件位置
	if(a[mid]<=3) 
        l=mid;
	else 
        r=mid;		   
}
cout<<"第一个3所在的下标为  "<<r<<endl;
return 0;
}	
```

**总结：**
**关键在于把区间分为两个情况：**

**<=x  >x  或者   \<x    >=x**

**其中前面改变左指针求最后一个满足条件位置
后面改变右指针求第一个满足条件位置**


**细节说明**

*为什么L的初始值为-1，R的初始值为N*

? ?首先，如果二分本来就没有结果
比如对于本文例题 1 2 2 3 3 4，，如果你要寻找第一个 >=5 的数，你会发现，整个过程都在执行L=mid，最后得到的结果中,R是等于下标6的，他明显这个时候是越界的，说明我们找不到要寻找的数字，而如果我们一开始将R赋值为n-1，也就是赋值为下标5的时候，他返回的R是5，是没有越界的，被我们当成了答案，但其实这时候我们的二分是没有答案的,就发生了错误；
? ?其次，L最小值为-1，R最小值只能取到1，因为L+1！=R为循环结束条件，R最大值为N,同理则L的最大值为N-2，则（L+R）/2的取值范围是 [0,N)mid的值始终位于0到N的左闭右开区间里面,不会发生越界的错误；

*为什么循环结束的条件是while(L+1!=R)?*

? ?之前学过二分的小伙伴可能会发现，之前学的二分，他循环结束的条件是while(L<R)而这边给出的循环条件是while(L+1!=R) 其实，就是当L和R相邻的时候，循环就结束，而原本的while(L<R)是当两区间重合以后，循环才结束，所以之前我们需要判断对mid进行加一或者减一的操作，而且因为区间重合的问题，最后返回的L、R还要再进行判断，而这边的这个二分，因为区间反回的是不重合的两区间，只有L=mid和R=mid这两种情况，最后根据需要返回L或者R；不会陷入死循环对于比较奇葩的情况，比如数组大小为1或者2比如int a[1],b[2];由于我们是while(L+1!=R)结束循环，也就是当L和R相邻的时候结束条件对于a[1],他的下标为0 此时L=-1，R=n也就是1对于b[2],他的下标为0,1 此时L=-1，R=n也就是2

所以无论何种情况，初始的L+1始终小于R，历经循环后最终L和R相邻，不会出现一开始L就和R重合等情况导致出现while(L+1!=R)循环不能结束的情况





*例1 数的范围*

给定一个按照升序排列的长度为 n
 的整数数组，以及 q
 个查询。
对于每个查询，返回一个元素 k
 的起始位置和终止位置（位置从 0
 开始计数）。

如果数组中不存在该元素，则返回 -1 -1。

输入格式
第一行包含整数 n
 和 q
，表示数组长度和询问个数。

第二行包含 n
 个整数（均在 1?10000
 范围内），表示完整数组。

接下来 q
 行，每行包含一个整数 k
，表示一个询问元素。

输出格式
共 q
 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 -1 -1。

数据范围
1≤n≤100000

1≤q≤10000

1≤k≤10000

```
#include<iostream>
using namespace std;
const int N=1e5+5;
int n,m,q[N];
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&q[i]);
    while(m--)
    {
        int k;scanf("%d",&k);
        //寻找第一个等于K的坐标 我这边让二分的边界定为 左边为<5 右边>=5 则所求为r
        int l=-1,r=n;
        while(l+1!=r)//当l与r没有相接的时候,求边界
        {
            int mid=l+r>>1;
            //下面找第一个>=5的坐标
            if(q[mid]>=k) r=mid;
            else l=mid;
        }
        //此时得到的r是第一个>=5的坐标
        if(q[r]!=k) printf("-1 -1\n");
        else{
            printf("%d ",r);
                //现在找最后一个<=5的数字 我这边让二分的左边为<=5 右边为>5 则所求为ll
                int ll=-1,rr=n;
                while(ll+1!=rr)
                {
                    
                    int mid=ll+rr>>1;
                    if(q[mid]<=k) ll=mid;
                    else rr=mid;
                }
                if(q[ll]!=k) printf("%d\n",r);
                else printf("%d\n",ll);
            }
    }
    
}

```


*例2 数的三次方根*

给定一个浮点数 n，求它的三次方根。

输入格式
共一行，包含一个浮点数 n。

输出格式
共一行，包含一个浮点数，表示问题的解。

注意，结果保留 6位小数。

数据范围
-10000≤n≤10000

```
#include<iostream>

using namespace std;
const int maxn=10000;

int main()
{
	double x;
	cin>>x;
	
	double l=-10000,r=10000;
	
    //一般比要求精度多两位
	while(r-l>1e-8){
		double mid=(l+r)/2;
		if(mid*mid*mid>=x){
			r=mid;
		}
		else{
			l=mid;
		}
	}
    //printf lf默认输出6位小数
	printf("%lf\n",l);

	return 0;
}
```
